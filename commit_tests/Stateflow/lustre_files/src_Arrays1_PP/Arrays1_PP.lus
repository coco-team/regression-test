-- This file has been generated by CoCoSim


-- System nodes








-- Entry action for state :Arrays1_B36
node Arrays1_B36_en(idArrays1_Arrays134_1:int;
	x_2_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int;
	x_2:int);


var 	idArrays1_Arrays134_2:int;
	x_2_2:int;


let



	-- set state as active 
	idArrays1_Arrays134_2 
	= 36;
	

	x_2_2 
	= if (not isInner) then  x_2_1  + 1
	 else x_2_1;
	

	(idArrays1_Arrays134, x_2) 
	= (idArrays1_Arrays134_2, x_2_2);
	

tel





-- Exit action for state :Arrays1_B36
node Arrays1_B36_ex(idArrays1_Arrays134_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int);


var 	idArrays1_Arrays134_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays134_2
	 = if (not isInner) then 0 else idArrays1_Arrays134_1;


	(idArrays1_Arrays134) 
	= (idArrays1_Arrays134_1);
	

tel






-- Entry action for state :Arrays1_A35
node Arrays1_A35_en(idArrays1_Arrays134_1:int;
	x_1_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int;
	x_1:int);


var 	idArrays1_Arrays134_2:int;
	x_1_2:int;


let



	-- set state as active 
	idArrays1_Arrays134_2 
	= 35;
	

	x_1_2 
	= if (not isInner) then  x_1_1  + 1
	 else x_1_1;
	

	(idArrays1_Arrays134, x_1) 
	= (idArrays1_Arrays134_2, x_1_2);
	

tel





-- Exit action for state :Arrays1_A35
node Arrays1_A35_ex(idArrays1_Arrays134_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int);


var 	idArrays1_Arrays134_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays134_2
	 = if (not isInner) then 0 else idArrays1_Arrays134_1;


	(idArrays1_Arrays134) 
	= (idArrays1_Arrays134_1);
	

tel






-- Entry action for state :Arrays1_C37
node Arrays1_C37_en(idArrays1_Arrays134_1:int;
	x_3_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int;
	x_3:int);


var 	idArrays1_Arrays134_2:int;
	x_3_2:int;


let



	-- set state as active 
	idArrays1_Arrays134_2 
	= 37;
	

	x_3_2 
	= if (not isInner) then  x_3_1  + 1
	 else x_3_1;
	

	(idArrays1_Arrays134, x_3) 
	= (idArrays1_Arrays134_2, x_3_2);
	

tel





-- Exit action for state :Arrays1_C37
node Arrays1_C37_ex(idArrays1_Arrays134_1:int;
	isInner:bool)

returns (idArrays1_Arrays134:int);


var 	idArrays1_Arrays134_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays134_2
	 = if (not isInner) then 0 else idArrays1_Arrays134_1;


	(idArrays1_Arrays134) 
	= (idArrays1_Arrays134_1);
	

tel


--***************************************************State :Arrays1_Arrays134 Automaton***************************************************

node Arrays1_Arrays134_node(idArrays1_Arrays134_1:int;
	x_1_1:int;
	E:bool;
	x_2_1:int;
	x_3_1:int)

returns (idArrays1_Arrays134:int;
	x_1:int;
	x_2:int;
	x_3:int);


let

	 automaton arrays1_arrays134

	state POINTArrays1_Arrays134:
	unless (idArrays1_Arrays134_1=0) restart POINT__TO__ARRAYS1_A35_1



	unless (idArrays1_Arrays134_1=35) and E restart ARRAYS1_A35__TO__ARRAYS1_B36_1



	unless (idArrays1_Arrays134_1=36) and E restart ARRAYS1_B36__TO__ARRAYS1_C37_1



	unless (idArrays1_Arrays134_1=37) and E restart ARRAYS1_C37__TO__ARRAYS1_A35_1



	unless (idArrays1_Arrays134_1=35) restart ARRAYS1_A35_IDL

	unless (idArrays1_Arrays134_1=36) restart ARRAYS1_B36_IDL

	unless (idArrays1_Arrays134_1=37) restart ARRAYS1_C37_IDL

	let

		(idArrays1_Arrays134, x_1, x_2, x_3) 
	= (idArrays1_Arrays134_1, x_1_1, x_2_1, x_3_1);
	

	tel



	state POINT__TO__ARRAYS1_A35_1:

	 var 	idArrays1_Arrays134_2:int;
	x_1_2:int;
	let

		-- transition trace :
	--POINT__To__Arrays1_A35_1
		(idArrays1_Arrays134_2, x_1_2) 
	= Arrays1_A35_en(idArrays1_Arrays134_1, x_1_1, false);
		

	(idArrays1_Arrays134, x_1) 
	=  (idArrays1_Arrays134_2, x_1_2);

	--add unused variables
	(x_2, x_3) 
	= (x_2_1, x_3_1);
	

	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_A35__TO__ARRAYS1_B36_1:

	 var 	idArrays1_Arrays134_2, idArrays1_Arrays134_3:int;
	x_2_2:int;
	let

		-- transition trace :
	--Arrays1_A35__To__Arrays1_B36_1
		(idArrays1_Arrays134_2) 
	= Arrays1_A35_ex(idArrays1_Arrays134_1, false);
		

		(idArrays1_Arrays134_3, x_2_2) 
	= Arrays1_B36_en(idArrays1_Arrays134_2, x_2_1, false);
		

	(idArrays1_Arrays134, x_1, x_2) 
	=  (idArrays1_Arrays134_3, x_1_1, x_2_2);

	--add unused variables
	(x_3) 
	= (x_3_1);
	

	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_B36__TO__ARRAYS1_C37_1:

	 var 	idArrays1_Arrays134_2, idArrays1_Arrays134_3:int;
	x_3_2:int;
	let

		-- transition trace :
	--Arrays1_B36__To__Arrays1_C37_1
		(idArrays1_Arrays134_2) 
	= Arrays1_B36_ex(idArrays1_Arrays134_1, false);
		

		(idArrays1_Arrays134_3, x_3_2) 
	= Arrays1_C37_en(idArrays1_Arrays134_2, x_3_1, false);
		

	(idArrays1_Arrays134, x_1, x_2, x_3) 
	=  (idArrays1_Arrays134_3, x_1_1, x_2_1, x_3_2);


	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_C37__TO__ARRAYS1_A35_1:

	 var 	idArrays1_Arrays134_2, idArrays1_Arrays134_3:int;
	x_1_2:int;
	let

		-- transition trace :
	--Arrays1_C37__To__Arrays1_A35_1
		(idArrays1_Arrays134_2) 
	= Arrays1_C37_ex(idArrays1_Arrays134_1, false);
		

		(idArrays1_Arrays134_3, x_1_2) 
	= Arrays1_A35_en(idArrays1_Arrays134_2, x_1_1, false);
		

	(idArrays1_Arrays134, x_1, x_2, x_3) 
	=  (idArrays1_Arrays134_3, x_1_2, x_2_1, x_3_1);


	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_A35_IDL:

	 	let

		

	(idArrays1_Arrays134, x_1, x_2, x_3) 
	= (idArrays1_Arrays134_1, x_1_1, x_2_1, x_3_1);
	

	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_B36_IDL:

	 	let

		

	(idArrays1_Arrays134, x_1, x_2, x_3) 
	= (idArrays1_Arrays134_1, x_1_1, x_2_1, x_3_1);
	

	tel

	until true restart POINTArrays1_Arrays134



	state ARRAYS1_C37_IDL:

	 	let

		

	(idArrays1_Arrays134, x_1, x_2, x_3) 
	= (idArrays1_Arrays134_1, x_1_1, x_2_1, x_3_1);
	

	tel

	until true restart POINTArrays1_Arrays134



tel


--***************************************************State :Arrays1_Arrays134 Automaton***************************************************

node Arrays1_PP_Arrays1(E:bool)

returns (x_1:int;
	x_2:int;
	x_3:int);


var x_1_1: int;

	x_2_1: int;

	x_3_1: int;

	idArrays1_Arrays134, idArrays1_Arrays134_1: int;

	let

	x_1_1 = 1 -> pre x_1;

	x_2_1 = 1 -> pre x_2;

	x_3_1 = 1 -> pre x_3;

	idArrays1_Arrays134_1 = 0 -> pre idArrays1_Arrays134;

	



	(idArrays1_Arrays134, x_1, x_2, x_3)
	 = 

	 if E then Arrays1_Arrays134_node(idArrays1_Arrays134_1, x_1_1, E, x_2_1, x_3_1)

	 else (idArrays1_Arrays134_1, x_1_1, x_2_1, x_3_1);

	


--unused outputs
	

tel



node Arrays1_PP (E_1_1 : real)
returns (x1_1_1 : int;
	x2_2_1 : int;
	x3_3_1 : int); 
var
	Arrays1_1_1 : int; Arrays1_1_2 : int; Arrays1_1_3 : int;
	Demux_1_1 : int; Demux_2_1 : int; Demux_3_1 : int;
	i_virtual_local : real;
	Arrays1E_1_1_event: bool;
let 
	Arrays1E_1_1_event = false -> (pre(E_1_1) <= 0.0 and E_1_1 > 0.0);
	(Arrays1_1_1, Arrays1_1_2, Arrays1_1_3) =  Arrays1_PP_Arrays1(Arrays1E_1_1_event);
	Demux_1_1 = Arrays1_1_1 ;
	Demux_2_1 = Arrays1_1_2 ;
	Demux_3_1 = Arrays1_1_3 ;
	x1_1_1 = Demux_1_1;
	x2_2_1 = Demux_2_1;
	x3_3_1 = Demux_3_1;
	i_virtual_local= 0.0 -> 1.0;
tel

