-- This file has been generated by CoCoSim

#open <conv>

-- System nodes
node integrator_ext_IC_reset_test_PP_Integrator8 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator7 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator6 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : bool; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator5 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator4 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator3 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : bool; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator2 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : bool; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator11 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP_Integrator1 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : bool; x0_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = (int_to_real(x0_1_1)) * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + (int_to_real(x0_1_1));
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_IC_reset_test_PP (In4_1_1 : real; In7_1_1 : real; In11_1_1 : int; In14_1_1 : int; In18_1_1 : bool; In21_1_1 : int; In1_1_1 : real; In2_1_1 : real; In3_1_1 : int; In5_1_1 : int; In6_1_1 : bool; In8_1_1 : int; In9_1_1 : real; In10_1_1 : real; In12_1_1 : int; In13_1_1 : int; In15_1_1 : bool; In16_1_1 : int; In17_1_1 : bool; In19_1_1 : bool; In20_1_1 : bool; In22_1_1 : bool; In23_1_1 : bool; In24_1_1 : bool; In25_1_1 : bool; In26_1_1 : bool; In27_1_1 : bool)
returns (Out4_1_1 : real;
	Out8_2_1 : real;
	Out12_3_1 : real;
	Out1_4_1 : real;
	Out2_5_1 : real;
	Out3_6_1 : real;
	Out5_7_1 : real;
	Out6_8_1 : real;
	Out7_9_1 : real); 
var
	Integrator1_1_1 : real;
	Integrator11_1_1 : real;
	Integrator2_1_1 : real;
	Integrator3_1_1 : real;
	Integrator4_1_1 : real;
	Integrator5_1_1 : real;
	Integrator6_1_1 : real;
	Integrator7_1_1 : real;
	Integrator8_1_1 : real;
	i_virtual_local : real;
let 
	Integrator1_1_1 = integrator_ext_IC_reset_test_PP_Integrator1(In6_1_1, In22_1_1, In8_1_1);
	Integrator11_1_1 = integrator_ext_IC_reset_test_PP_Integrator11(In18_1_1, In20_1_1, In21_1_1);
	Integrator2_1_1 = integrator_ext_IC_reset_test_PP_Integrator2(In1_1_1, In24_1_1, In2_1_1);
	Integrator3_1_1 = integrator_ext_IC_reset_test_PP_Integrator3(In4_1_1, In17_1_1, In7_1_1);
	Integrator4_1_1 = integrator_ext_IC_reset_test_PP_Integrator4(In3_1_1, In23_1_1, In5_1_1);
	Integrator5_1_1 = integrator_ext_IC_reset_test_PP_Integrator5(In15_1_1, In27_1_1, In16_1_1);
	Integrator6_1_1 = integrator_ext_IC_reset_test_PP_Integrator6(In9_1_1, In25_1_1, In10_1_1);
	Integrator7_1_1 = integrator_ext_IC_reset_test_PP_Integrator7(In11_1_1, In19_1_1, In14_1_1);
	Integrator8_1_1 = integrator_ext_IC_reset_test_PP_Integrator8(In12_1_1, In26_1_1, In13_1_1);
	Out4_1_1 = Integrator3_1_1;
	Out8_2_1 = Integrator7_1_1;
	Out12_3_1 = Integrator11_1_1;
	Out1_4_1 = Integrator2_1_1;
	Out2_5_1 = Integrator4_1_1;
	Out3_6_1 = Integrator1_1_1;
	Out5_7_1 = Integrator6_1_1;
	Out6_8_1 = Integrator8_1_1;
	Out7_9_1 = Integrator5_1_1;
	i_virtual_local= 0.0 -> 1.0;
tel

