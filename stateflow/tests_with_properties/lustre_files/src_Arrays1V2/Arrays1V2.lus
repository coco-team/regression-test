-- This file has been generated by cocoSim


-- Properties nodes
node Arrays1V2_prop (E_1_1 : real; F_1_1 : real)
returns (prop_1_1 : bool);
var
	LogicalOperator_1_1 : bool;
	RelationalOperator_1_1 : bool;
	RelationalOperator1_1_1 : bool;
	x1_1_1 : int;
	x2_1_1 : int;
	x3_1_1 : int;
let
	LogicalOperator_1_1 = RelationalOperator_1_1 and RelationalOperator1_1_1;
	RelationalOperator_1_1 = x1_1_1 >= x2_1_1;
	RelationalOperator1_1_1 = x2_1_1 >= x3_1_1;
	prop_1_1 = LogicalOperator_1_1;

	(x1_1_1, x2_1_1, x3_1_1) = Arrays1V2(E_1_1, F_1_1);
	--%PROPERTY prop_1_1; 
 
tel

node Arrays1V2_prop2 (E_1_1 : real; F_1_1 : real)
returns (prop2_1_1 : bool);
var
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	LogicalOperator_1_1 : bool;
	Subtract_1_1 : int;
	Subtract1_1_1 : int;
	x1_1_1 : int;
	x2_1_1 : int;
	x3_1_1 : int;
let
	CompareToConstant_1_1 = Subtract_1_1 <= 1;
	CompareToConstant1_1_1 = Subtract1_1_1 <= 1;
	LogicalOperator_1_1 = CompareToConstant_1_1 and CompareToConstant1_1_1;
	Subtract_1_1 = x1_1_1 - x2_1_1;
	Subtract1_1_1 = x2_1_1 - x3_1_1;
	prop2_1_1 = LogicalOperator_1_1;

	(x1_1_1, x2_1_1, x3_1_1) = Arrays1V2(E_1_1, F_1_1);
	--%PROPERTY prop2_1_1; 
 
tel


-- System nodes








-- Entry action for state :Arrays1_B
node Arrays1_B_en(idArrays1_Arrays1_1:int;
	x2_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int;
	x2:int);


var 	idArrays1_Arrays1_2:int;
	x2_2:int;


let



	-- set state as active 
	idArrays1_Arrays1_2 
	= 525;
	

	x2_2 
	= if (not isInner) then  x2_1  + 1
	 else x2_1;
	

	(idArrays1_Arrays1, x2) 
	= (idArrays1_Arrays1_2, x2_2);
	

tel





-- Exit action for state :Arrays1_B
node Arrays1_B_ex(idArrays1_Arrays1_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int);


var 	idArrays1_Arrays1_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays1_2
	 = if (not isInner) then 0 else idArrays1_Arrays1_1;


	(idArrays1_Arrays1) 
	= (idArrays1_Arrays1_1);
	

tel






-- Entry action for state :Arrays1_A
node Arrays1_A_en(idArrays1_Arrays1_1:int;
	x1_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int;
	x1:int);


var 	idArrays1_Arrays1_2:int;
	x1_2:int;


let



	-- set state as active 
	idArrays1_Arrays1_2 
	= 524;
	

	x1_2 
	= if (not isInner) then  x1_1  + 1
	 else x1_1;
	

	(idArrays1_Arrays1, x1) 
	= (idArrays1_Arrays1_2, x1_2);
	

tel





-- Exit action for state :Arrays1_A
node Arrays1_A_ex(idArrays1_Arrays1_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int);


var 	idArrays1_Arrays1_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays1_2
	 = if (not isInner) then 0 else idArrays1_Arrays1_1;


	(idArrays1_Arrays1) 
	= (idArrays1_Arrays1_1);
	

tel






-- Entry action for state :Arrays1_C
node Arrays1_C_en(idArrays1_Arrays1_1:int;
	x3_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int;
	x3:int);


var 	idArrays1_Arrays1_2:int;
	x3_2:int;


let



	-- set state as active 
	idArrays1_Arrays1_2 
	= 526;
	

	x3_2 
	= if (not isInner) then  x3_1  + 1
	 else x3_1;
	

	(idArrays1_Arrays1, x3) 
	= (idArrays1_Arrays1_2, x3_2);
	

tel





-- Exit action for state :Arrays1_C
node Arrays1_C_ex(idArrays1_Arrays1_1:int;
	isInner:bool)

returns (idArrays1_Arrays1:int);


var 	idArrays1_Arrays1_2:int;


let



	-- set state as inactive 
	idArrays1_Arrays1_2
	 = if (not isInner) then 0 else idArrays1_Arrays1_1;


	(idArrays1_Arrays1) 
	= (idArrays1_Arrays1_1);
	

tel


--***************************************************State :Arrays1_Arrays1 Automaton***************************************************

node Arrays1_Arrays1_node(idArrays1_Arrays1_1:int;
	x1_1:int;
	E:bool;
	x2_1:int;
	F:bool;
	x3_1:int)

returns (idArrays1_Arrays1:int;
	x1:int;
	x2:int;
	x3:int);


let

	 automaton arrays1_arrays1

	state POINTArrays1_Arrays1:
	unless (idArrays1_Arrays1_1=0) restart POINT__TO__ARRAYS1_A_1



	unless (idArrays1_Arrays1_1=524) and E restart ARRAYS1_A__TO__ARRAYS1_B_1



	unless (idArrays1_Arrays1_1=525) and F restart ARRAYS1_B__TO__ARRAYS1_C_1



	unless (idArrays1_Arrays1_1=526) and E restart ARRAYS1_C__TO__ARRAYS1_A_1



	unless (idArrays1_Arrays1_1=524) restart ARRAYS1_A_IDL

	unless (idArrays1_Arrays1_1=525) restart ARRAYS1_B_IDL

	unless (idArrays1_Arrays1_1=526) restart ARRAYS1_C_IDL

	let

		(idArrays1_Arrays1, x1, x2, x3) 
	= (idArrays1_Arrays1_1, x1_1, x2_1, x3_1);
	

	tel



	state POINT__TO__ARRAYS1_A_1:

	 var 	idArrays1_Arrays1_2:int;
	x1_2:int;
	let

		-- transition trace :
	--POINT__To__Arrays1_A_1
		(idArrays1_Arrays1_2, x1_2) 
	= Arrays1_A_en(idArrays1_Arrays1_1, x1_1, false);
		

	(idArrays1_Arrays1, x1) 
	=  (idArrays1_Arrays1_2, x1_2);

	--add unused variables
	(x2, x3) 
	= (x2_1, x3_1);
	

	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_A__TO__ARRAYS1_B_1:

	 var 	idArrays1_Arrays1_2, idArrays1_Arrays1_3:int;
	x2_2:int;
	let

		-- transition trace :
	--Arrays1_A__To__Arrays1_B_1
		(idArrays1_Arrays1_2) 
	= Arrays1_A_ex(idArrays1_Arrays1_1, false);
		

		(idArrays1_Arrays1_3, x2_2) 
	= Arrays1_B_en(idArrays1_Arrays1_2, x2_1, false);
		

	(idArrays1_Arrays1, x1, x2) 
	=  (idArrays1_Arrays1_3, x1_1, x2_2);

	--add unused variables
	(x3) 
	= (x3_1);
	

	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_B__TO__ARRAYS1_C_1:

	 var 	idArrays1_Arrays1_2, idArrays1_Arrays1_3:int;
	x3_2:int;
	let

		-- transition trace :
	--Arrays1_B__To__Arrays1_C_1
		(idArrays1_Arrays1_2) 
	= Arrays1_B_ex(idArrays1_Arrays1_1, false);
		

		(idArrays1_Arrays1_3, x3_2) 
	= Arrays1_C_en(idArrays1_Arrays1_2, x3_1, false);
		

	(idArrays1_Arrays1, x1, x2, x3) 
	=  (idArrays1_Arrays1_3, x1_1, x2_1, x3_2);


	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_C__TO__ARRAYS1_A_1:

	 var 	idArrays1_Arrays1_2, idArrays1_Arrays1_3:int;
	x1_2:int;
	let

		-- transition trace :
	--Arrays1_C__To__Arrays1_A_1
		(idArrays1_Arrays1_2) 
	= Arrays1_C_ex(idArrays1_Arrays1_1, false);
		

		(idArrays1_Arrays1_3, x1_2) 
	= Arrays1_A_en(idArrays1_Arrays1_2, x1_1, false);
		

	(idArrays1_Arrays1, x1, x2, x3) 
	=  (idArrays1_Arrays1_3, x1_2, x2_1, x3_1);


	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_A_IDL:

	 	let

		

	(idArrays1_Arrays1, x1, x2, x3) 
	= (idArrays1_Arrays1_1, x1_1, x2_1, x3_1);
	

	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_B_IDL:

	 	let

		

	(idArrays1_Arrays1, x1, x2, x3) 
	= (idArrays1_Arrays1_1, x1_1, x2_1, x3_1);
	

	tel

	until true restart POINTArrays1_Arrays1



	state ARRAYS1_C_IDL:

	 	let

		

	(idArrays1_Arrays1, x1, x2, x3) 
	= (idArrays1_Arrays1_1, x1_1, x2_1, x3_1);
	

	tel

	until true restart POINTArrays1_Arrays1



tel


--***************************************************State :Arrays1_Arrays1 Automaton***************************************************

node Arrays1V2_Arrays1(E:bool;
	F:bool)

returns (x1:int;
	x2:int;
	x3:int);


var x1_1: int;

	x2_1: int;

	x3_1: int;

	idArrays1_Arrays1, idArrays1_Arrays1_1: int;

		idArrays1_Arrays1_2:int;
	x1_2:int;
	x2_2:int;
	x3_2:int;
let

	x1_1 = 1 -> pre x1;

	x2_1 = 1 -> pre x2;

	x3_1 = 1 -> pre x3;

	idArrays1_Arrays1_1 = 0 -> pre idArrays1_Arrays1;

	



	(idArrays1_Arrays1_2, x1_2, x2_2, x3_2)
	 = 

	 if E then Arrays1_Arrays1_node(idArrays1_Arrays1_1, x1_1, E, x2_1, false, x3_1)

	 else (idArrays1_Arrays1_1, x1_1, x2_1, x3_1);

	



	(idArrays1_Arrays1, x1, x2, x3)
	 = 

	 if F then Arrays1_Arrays1_node(idArrays1_Arrays1_2, x1_2, false, x2_2, F, x3_2)

	 else (idArrays1_Arrays1_2, x1_2, x2_2, x3_2);

	


--unused outputs
	

tel



node Arrays1V2 (E_1_1 : real; F_1_1 : real)
returns (x1_1_1 : int;
	x2_2_1 : int;
	x3_3_1 : int); 
var
	Arrays1_1_1 : int; Arrays1_2_1 : int; Arrays1_3_1 : int;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux_1_1_event: bool;
	Mux_1_2_event: bool;
let 
	Mux_1_1_event = false -> (pre(Mux_1_1) > 0.0 and Mux_1_1 <= 0.0);
	Mux_1_2_event = false -> (pre(Mux_1_2) <= 0.0 and Mux_1_2 > 0.0);
	(Arrays1_1_1, Arrays1_2_1, Arrays1_3_1) =  Arrays1V2_Arrays1(Mux_1_1_event, Mux_1_2_event);
	Mux_1_1 = E_1_1 ;
	Mux_1_2 = F_1_1 ;
	x1_1_1 = Arrays1_1_1;
	x2_2_1 = Arrays1_2_1;
	x3_3_1 = Arrays1_3_1;
tel

