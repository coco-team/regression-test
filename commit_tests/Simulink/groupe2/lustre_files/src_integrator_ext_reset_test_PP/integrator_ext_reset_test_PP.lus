-- This file has been generated by CoCoSim

#open <conv>

-- System nodes
node integrator_ext_reset_test_PP_Integrator9 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator8 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_rising_1_1;
	eq0_1_1 = (int_to_real(reset_rising_1_1)) > zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator7 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_rising_1_1;
	eq0_1_1 = (int_to_real(reset_rising_1_1)) > zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator6 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_rising_1_1;
	eq0_1_1 = (int_to_real(reset_rising_1_1)) > zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator5 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : real;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0.00000000 -> pre reset_rising_1_1;
	eq0_1_1 = reset_rising_1_1 > zero_1_1;
	ne1_1_1 = UnitDelay2_1_1 <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator4 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : real;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0.00000000 -> pre reset_rising_1_1;
	eq0_1_1 = reset_rising_1_1 > zero_1_1;
	ne1_1_1 = UnitDelay2_1_1 <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator3 (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : real;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0.00000000 -> pre reset_rising_1_1;
	eq0_1_1 = reset_rising_1_1 > zero_1_1;
	ne1_1_1 = UnitDelay2_1_1 <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator11 (f_lpar_x_rpar__1_1 : bool; reset_rising_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * (if f_lpar_x_rpar__1_1 then 1.0 else 0.0);
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP_Integrator10 (f_lpar_x_rpar__1_1 : int; reset_rising_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : int;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = (int_to_real(Sample_1_1)) + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node integrator_ext_reset_test_PP (In4_1_1 : real; In5_1_1 : int; In6_1_1 : bool; In7_1_1 : real; In8_1_1 : real; In9_1_1 : real; In10_1_1 : real; In11_1_1 : int; In12_1_1 : bool; In13_1_1 : int; In14_1_1 : int; In15_1_1 : int; In16_1_1 : real; In17_1_1 : int; In18_1_1 : bool; In19_1_1 : bool; In20_1_1 : bool; In21_1_1 : bool)
returns (Out4_1_1 : real;
	Out5_2_1 : real;
	Out6_3_1 : real;
	Out7_4_1 : real;
	Out8_5_1 : real;
	Out9_6_1 : real;
	Out10_7_1 : real;
	Out11_8_1 : real;
	Out12_9_1 : real); 
var
	Integrator10_1_1 : real;
	Integrator11_1_1 : real;
	Integrator3_1_1 : real;
	Integrator4_1_1 : real;
	Integrator5_1_1 : real;
	Integrator6_1_1 : real;
	Integrator7_1_1 : real;
	Integrator8_1_1 : real;
	Integrator9_1_1 : real;
	i_virtual_local : real;
let 
	Integrator10_1_1 = integrator_ext_reset_test_PP_Integrator10(In17_1_1, In20_1_1);
	Integrator11_1_1 = integrator_ext_reset_test_PP_Integrator11(In18_1_1, In21_1_1);
	Integrator3_1_1 = integrator_ext_reset_test_PP_Integrator3(In4_1_1, In7_1_1);
	Integrator4_1_1 = integrator_ext_reset_test_PP_Integrator4(In5_1_1, In8_1_1);
	Integrator5_1_1 = integrator_ext_reset_test_PP_Integrator5(In6_1_1, In9_1_1);
	Integrator6_1_1 = integrator_ext_reset_test_PP_Integrator6(In10_1_1, In13_1_1);
	Integrator7_1_1 = integrator_ext_reset_test_PP_Integrator7(In11_1_1, In14_1_1);
	Integrator8_1_1 = integrator_ext_reset_test_PP_Integrator8(In12_1_1, In15_1_1);
	Integrator9_1_1 = integrator_ext_reset_test_PP_Integrator9(In16_1_1, In19_1_1);
	Out4_1_1 = Integrator3_1_1;
	Out5_2_1 = Integrator4_1_1;
	Out6_3_1 = Integrator5_1_1;
	Out7_4_1 = Integrator6_1_1;
	Out8_5_1 = Integrator7_1_1;
	Out9_6_1 = Integrator8_1_1;
	Out10_7_1 = Integrator9_1_1;
	Out11_8_1 = Integrator10_1_1;
	Out12_9_1 = Integrator11_1_1;
	i_virtual_local= 0.0 -> 1.0;
tel

