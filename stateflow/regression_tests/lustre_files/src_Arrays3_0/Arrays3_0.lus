-- This file has been generated by cocoSim


-- System nodes








-- Entry action for state :Arrays2_B
node Arrays2_B_en(idArrays2_Arrays2_1:int;
	x_1_1_1_1:int;
	s_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int;
	x_1_1_1:int;
	s:int);


var 	idArrays2_Arrays2_2:int;
	x_1_1_1_2, x_1_1_1_3, x_1_1_1_4, x_1_1_1_5:int;
	s_2:int;


let



	-- set state as active 
	idArrays2_Arrays2_2 
	= 90;
	

	x_1_1_1_2 
	= if (not isInner) then  x_1_1_1_1  + 1
	 else x_1_1_1_1;
	

	x_1_1_1_3 
	= if (not isInner) then  x_1_1_1_2 +2
	 else x_1_1_1_2;
	

	x_1_1_1_4 
	= if (not isInner) then  x_1_1_1_3 +3
	 else x_1_1_1_3;
	

	x_1_1_1_5 
	= if (not isInner) then  x_1_1_1_4 +1
	 else x_1_1_1_4;
	

	s_2 
	= if (not isInner) then 2
	 else s_1;
	

	(idArrays2_Arrays2, x_1_1_1, s) 
	= (idArrays2_Arrays2_2, x_1_1_1_5, s_2);
	

tel





-- Exit action for state :Arrays2_B
node Arrays2_B_ex(idArrays2_Arrays2_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int);


var 	idArrays2_Arrays2_2:int;


let



	-- set state as inactive 
	idArrays2_Arrays2_2
	 = if (not isInner) then 0 else idArrays2_Arrays2_1;


	(idArrays2_Arrays2) 
	= (idArrays2_Arrays2_1);
	

tel






-- Entry action for state :Arrays2_A
node Arrays2_A_en(idArrays2_Arrays2_1:int;
	x_1_1_1_1:int;
	s_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int;
	x_1_1_1:int;
	s:int);


var 	idArrays2_Arrays2_2:int;
	x_1_1_1_2, x_1_1_1_3, x_1_1_1_4, x_1_1_1_5:int;
	s_2:int;


let



	-- set state as active 
	idArrays2_Arrays2_2 
	= 89;
	

	x_1_1_1_2 
	= if (not isInner) then  x_1_1_1_1  + 1
	 else x_1_1_1_1;
	

	x_1_1_1_3 
	= if (not isInner) then  x_1_1_1_2 +2
	 else x_1_1_1_2;
	

	x_1_1_1_4 
	= if (not isInner) then  x_1_1_1_3 +3
	 else x_1_1_1_3;
	

	x_1_1_1_5 
	= if (not isInner) then  x_1_1_1_4 +1
	 else x_1_1_1_4;
	

	s_2 
	= if (not isInner) then 1
	 else s_1;
	

	(idArrays2_Arrays2, x_1_1_1, s) 
	= (idArrays2_Arrays2_2, x_1_1_1_5, s_2);
	

tel





-- Exit action for state :Arrays2_A
node Arrays2_A_ex(idArrays2_Arrays2_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int);


var 	idArrays2_Arrays2_2:int;


let



	-- set state as inactive 
	idArrays2_Arrays2_2
	 = if (not isInner) then 0 else idArrays2_Arrays2_1;


	(idArrays2_Arrays2) 
	= (idArrays2_Arrays2_1);
	

tel






-- Entry action for state :Arrays2_C
node Arrays2_C_en(idArrays2_Arrays2_1:int;
	x_2_1_1_1:int;
	s_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int;
	x_2_1_1:int;
	s:int);


var 	idArrays2_Arrays2_2:int;
	x_2_1_1_2, x_2_1_1_3, x_2_1_1_4, x_2_1_1_5:int;
	s_2:int;


let



	-- set state as active 
	idArrays2_Arrays2_2 
	= 91;
	

	x_2_1_1_2 
	= if (not isInner) then  x_2_1_1_1  + 1
	 else x_2_1_1_1;
	

	x_2_1_1_3 
	= if (not isInner) then  x_2_1_1_2 +2
	 else x_2_1_1_2;
	

	x_2_1_1_4 
	= if (not isInner) then  x_2_1_1_3 +3
	 else x_2_1_1_3;
	

	x_2_1_1_5 
	= if (not isInner) then  x_2_1_1_4 +1
	 else x_2_1_1_4;
	

	s_2 
	= if (not isInner) then 3
	 else s_1;
	

	(idArrays2_Arrays2, x_2_1_1, s) 
	= (idArrays2_Arrays2_2, x_2_1_1_5, s_2);
	

tel





-- Exit action for state :Arrays2_C
node Arrays2_C_ex(idArrays2_Arrays2_1:int;
	isInner:bool)

returns (idArrays2_Arrays2:int);


var 	idArrays2_Arrays2_2:int;


let



	-- set state as inactive 
	idArrays2_Arrays2_2
	 = if (not isInner) then 0 else idArrays2_Arrays2_1;


	(idArrays2_Arrays2) 
	= (idArrays2_Arrays2_1);
	

tel


--***************************************************State :Arrays2_Arrays2 Automaton***************************************************

node Arrays2_Arrays2_node(idArrays2_Arrays2_1:int;
	s_1:int;
	x_1_1_1_1:int;
	E:bool;
	x_2_1_1_1:int)

returns (idArrays2_Arrays2:int;
	s:int;
	x_1_1_1:int;
	x_2_1_1:int);


let

	 automaton arrays2_arrays2

	state POINTArrays2_Arrays2:
	unless (idArrays2_Arrays2_1=0) restart POINT__TO__ARRAYS2_A_1



	unless (idArrays2_Arrays2_1=89) and E restart ARRAYS2_A__TO__ARRAYS2_B_1



	unless (idArrays2_Arrays2_1=90) and E restart ARRAYS2_B__TO__ARRAYS2_C_1



	unless (idArrays2_Arrays2_1=91) and E restart ARRAYS2_C__TO__ARRAYS2_A_1



	unless (idArrays2_Arrays2_1=89) restart ARRAYS2_A_IDL

	unless (idArrays2_Arrays2_1=90) restart ARRAYS2_B_IDL

	unless (idArrays2_Arrays2_1=91) restart ARRAYS2_C_IDL

	let

		(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	= (idArrays2_Arrays2_1, s_1, x_1_1_1_1, x_2_1_1_1);
	

	tel



	state POINT__TO__ARRAYS2_A_1:

	 var 	idArrays2_Arrays2_2:int;
	s_2:int;
	x_1_1_1_2:int;
	let

		-- transition trace :
	--POINT__To__Arrays2_A_1
		(idArrays2_Arrays2_2, x_1_1_1_2, s_2) 
	= Arrays2_A_en(idArrays2_Arrays2_1, x_1_1_1_1, s_1, false);
		

	(idArrays2_Arrays2, s, x_1_1_1) 
	=  (idArrays2_Arrays2_2, s_2, x_1_1_1_2);

	--add unused variables
	(x_2_1_1) 
	= (x_2_1_1_1);
	

	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_A__TO__ARRAYS2_B_1:

	 var 	idArrays2_Arrays2_2, idArrays2_Arrays2_3:int;
	s_2:int;
	x_1_1_1_2:int;
	let

		-- transition trace :
	--Arrays2_A__To__Arrays2_B_1
		(idArrays2_Arrays2_2) 
	= Arrays2_A_ex(idArrays2_Arrays2_1, false);
		

		(idArrays2_Arrays2_3, x_1_1_1_2, s_2) 
	= Arrays2_B_en(idArrays2_Arrays2_2, x_1_1_1_1, s_1, false);
		

	(idArrays2_Arrays2, s, x_1_1_1) 
	=  (idArrays2_Arrays2_3, s_2, x_1_1_1_2);

	--add unused variables
	(x_2_1_1) 
	= (x_2_1_1_1);
	

	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_B__TO__ARRAYS2_C_1:

	 var 	idArrays2_Arrays2_2, idArrays2_Arrays2_3:int;
	s_2:int;
	x_2_1_1_2:int;
	let

		-- transition trace :
	--Arrays2_B__To__Arrays2_C_1
		(idArrays2_Arrays2_2) 
	= Arrays2_B_ex(idArrays2_Arrays2_1, false);
		

		(idArrays2_Arrays2_3, x_2_1_1_2, s_2) 
	= Arrays2_C_en(idArrays2_Arrays2_2, x_2_1_1_1, s_1, false);
		

	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	=  (idArrays2_Arrays2_3, s_2, x_1_1_1_1, x_2_1_1_2);


	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_C__TO__ARRAYS2_A_1:

	 var 	idArrays2_Arrays2_2, idArrays2_Arrays2_3:int;
	s_2:int;
	x_1_1_1_2:int;
	let

		-- transition trace :
	--Arrays2_C__To__Arrays2_A_1
		(idArrays2_Arrays2_2) 
	= Arrays2_C_ex(idArrays2_Arrays2_1, false);
		

		(idArrays2_Arrays2_3, x_1_1_1_2, s_2) 
	= Arrays2_A_en(idArrays2_Arrays2_2, x_1_1_1_1, s_1, false);
		

	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	=  (idArrays2_Arrays2_3, s_2, x_1_1_1_2, x_2_1_1_1);


	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_A_IDL:

	 	let

		

	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	= (idArrays2_Arrays2_1, s_1, x_1_1_1_1, x_2_1_1_1);
	

	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_B_IDL:

	 	let

		

	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	= (idArrays2_Arrays2_1, s_1, x_1_1_1_1, x_2_1_1_1);
	

	tel

	until true restart POINTArrays2_Arrays2



	state ARRAYS2_C_IDL:

	 	let

		

	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1) 
	= (idArrays2_Arrays2_1, s_1, x_1_1_1_1, x_2_1_1_1);
	

	tel

	until true restart POINTArrays2_Arrays2



tel


--***************************************************State :Arrays2_Arrays2 Automaton***************************************************

node Arrays3_0_Arrays2(E:bool)

returns (s:int);


var s_1: int;

	x_1_1_1, x_1_1_1_1: int;

	x_1_1_2, x_1_1_2_1: int;

	x_1_2_1, x_1_2_1_1: int;

	x_1_2_2, x_1_2_2_1: int;

	x_2_1_1, x_2_1_1_1: int;

	x_2_1_2, x_2_1_2_1: int;

	x_2_2_1, x_2_2_1_1: int;

	x_2_2_2, x_2_2_2_1: int;

	x_3_1_1, x_3_1_1_1: int;

	x_3_1_2, x_3_1_2_1: int;

	x_3_2_1, x_3_2_1_1: int;

	x_3_2_2, x_3_2_2_1: int;

	idArrays2_Arrays2, idArrays2_Arrays2_1: int;

	let

	s_1 = 0 -> pre s;

	x_1_1_1_1 = 0 -> pre x_1_1_1;

	x_1_1_2_1 = 0 -> pre x_1_1_2;

	x_1_2_1_1 = 0 -> pre x_1_2_1;

	x_1_2_2_1 = 0 -> pre x_1_2_2;

	x_2_1_1_1 = 0 -> pre x_2_1_1;

	x_2_1_2_1 = 0 -> pre x_2_1_2;

	x_2_2_1_1 = 0 -> pre x_2_2_1;

	x_2_2_2_1 = 0 -> pre x_2_2_2;

	x_3_1_1_1 = 0 -> pre x_3_1_1;

	x_3_1_2_1 = 0 -> pre x_3_1_2;

	x_3_2_1_1 = 0 -> pre x_3_2_1;

	x_3_2_2_1 = 0 -> pre x_3_2_2;

	idArrays2_Arrays2_1 = 0 -> pre idArrays2_Arrays2;

	



	(idArrays2_Arrays2, s, x_1_1_1, x_2_1_1)
	 = 

	 if E then Arrays2_Arrays2_node(idArrays2_Arrays2_1, s_1, x_1_1_1_1, E, x_2_1_1_1)

	 else (idArrays2_Arrays2_1, s_1, x_1_1_1_1, x_2_1_1_1);

	


--unused outputs
	x_1_1_2 = 0;

	x_1_2_1 = 0;

	x_1_2_2 = 0;

	x_2_1_2 = 0;

	x_2_2_1 = 0;

	x_2_2_2 = 0;

	x_3_1_1 = 0;

	x_3_1_2 = 0;

	x_3_2_1 = 0;

	x_3_2_2 = 0;

	

tel



node Arrays3_0 (E_1_1 : real)
returns (state_1_1 : int); 
var
	Arrays2_1_1 : int;
	E_1_1_event: bool;
let 
	E_1_1_event = false -> (pre(E_1_1) <= 0.0 and E_1_1 > 0.0);
	Arrays2_1_1 =  Arrays3_0_Arrays2(E_1_1_event);
	state_1_1 = Arrays2_1_1;
tel

