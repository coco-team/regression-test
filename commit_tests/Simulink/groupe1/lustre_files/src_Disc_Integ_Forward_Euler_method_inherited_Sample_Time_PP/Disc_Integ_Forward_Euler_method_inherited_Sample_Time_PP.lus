-- This file has been generated by CoCoSim

#open <conv>

-- System nodes
node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_without_reset_ext_IC1 (f_lpar_x_rpar__1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Sample_1_1 : real;
	Sum1_1_1 : real;
	UnitDelay_1_1 : real;
let 
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + UnitDelay_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	F_lpar_x_rpar__1_1 = UnitDelay_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_without_reset_ext_IC (f_lpar_x_rpar__1_1 : real; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	Product_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum3_1_1 = UnitDelay_1_1 + Product_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	F_lpar_x_rpar__1_1 = Sum3_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_sampled_level_int (f_lpar_x_rpar__1_1 : real; reset_either_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	eq0_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	eq0_1_1 = not((int_to_real(reset_either_1_1)) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_sampled_level_bool (f_lpar_x_rpar__1_1 : real; reset_either_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	eq0_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	eq0_1_1 = not((if reset_either_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_rising_edge_int (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_rising_1_1;
	eq0_1_1 = (int_to_real(reset_rising_1_1)) > zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_rising_edge_bool (f_lpar_x_rpar__1_1 : real; reset_rising_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_rising_1_1;
	eq0_1_1 = (if reset_rising_1_1 then 1.0 else 0.0) > zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_falling_edge_int (f_lpar_x_rpar__1_1 : real; reset_falling_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_falling_1_1;
	eq0_1_1 = (int_to_real(reset_falling_1_1)) <= zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) > zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_falling_edge_bool (f_lpar_x_rpar__1_1 : real; reset_falling_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_falling_1_1;
	eq0_1_1 = (if reset_falling_1_1 then 1.0 else 0.0) <= zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) > zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_either_edge_int (f_lpar_x_rpar__1_1 : real; reset_either_1_1 : int)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	DataTypeConversion3_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	eq1_1_1 : bool;
	ne1_1_1 : bool;
	ne2_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product2_1_1 + Product1_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if eq1_1_1 then 1.0 else 0.0);
	DataTypeConversion3_1_1 = (if ne2_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion2_1_1 * DataTypeConversion3_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_either_1_1;
	eq0_1_1 = (int_to_real(reset_either_1_1)) <= zero_1_1;
	eq1_1_1 = (int_to_real(UnitDelay2_1_1)) <= zero_1_1;
	ne1_1_1 = (int_to_real(UnitDelay2_1_1)) > zero_1_1;
	ne2_1_1 = (int_to_real(reset_either_1_1)) > zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_either_edge_bool (f_lpar_x_rpar__1_1 : real; reset_either_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	DataTypeConversion3_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	eq1_1_1 : bool;
	ne1_1_1 : bool;
	ne2_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product2_1_1 + Product1_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if eq1_1_1 then 1.0 else 0.0);
	DataTypeConversion3_1_1 = (if ne2_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion2_1_1 * DataTypeConversion3_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_either_1_1;
	eq0_1_1 = (if reset_either_1_1 then 1.0 else 0.0) <= zero_1_1;
	eq1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) <= zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) > zero_1_1;
	ne2_1_1 = (if reset_either_1_1 then 1.0 else 0.0) > zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_Level_int (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : int; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : int;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if ne0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion1_1_1 * DataTypeConversion2_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = 0 -> pre reset_level_1_1;
	eq0_1_1 = (int_to_real(reset_level_1_1)) = zero_1_1;
	ne0_1_1 = not((int_to_real(reset_level_1_1)) = zero_1_1);
	ne1_1_1 = not((int_to_real(UnitDelay2_1_1)) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_Level_bool (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if ne0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion1_1_1 * DataTypeConversion2_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_level_1_1;
	eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
	ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
	ne1_1_1 = not((if UnitDelay2_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_internal_IC (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if ne0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion1_1_1 * DataTypeConversion2_1_1;
	Sample_1_1 = 0.20000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_level_1_1;
	eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
	ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
	ne1_1_1 = not((if UnitDelay2_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP (x_1_1 : real; reset_1_1 : bool; IC_1_1 : real; x1_1_1 : real; reset1_1_1 : int; IC1_1_1 : real; x2_1_1 : real; reset2_1_1 : bool; x3_1_1 : real; IC3_1_1 : real; x4_1_1 : real; x5_1_1 : real; reset5_1_1 : bool; x6_1_1 : real; reset6_1_1 : int; x7_1_1 : real; reset3_1_1 : bool; x8_1_1 : real; reset4_1_1 : int; x9_1_1 : real; reset7_1_1 : bool; x10_1_1 : real; reset8_1_1 : int; x11_1_1 : real; reset11_1_1 : bool; x12_1_1 : real; reset12_1_1 : int)
returns (y_1_1 : real;
	y1_2_1 : real;
	y2_3_1 : real;
	y3_4_1 : real;
	y4_5_1 : real;
	y5_6_1 : real;
	y6_7_1 : real;
	y7_8_1 : real;
	y8_9_1 : real;
	y9_10_1 : real;
	y10_11_1 : real;
	y11_12_1 : real;
	y12_13_1 : real); 
var
	internal_IC_1_1 : real;
	reset_Level_bool_1_1 : real;
	reset_Level_int_1_1 : real;
	reset_either_edge_bool_1_1 : real;
	reset_either_edge_int_1_1 : real;
	reset_falling_edge_bool_1_1 : real;
	reset_falling_edge_int_1_1 : real;
	reset_rising_edge_bool_1_1 : real;
	reset_rising_edge_int_1_1 : real;
	reset_sampled_level_bool_1_1 : real;
	reset_sampled_level_int_1_1 : real;
	without_reset_ext_IC_1_1 : real;
	without_reset_ext_IC1_1_1 : real;
	i_virtual_local : real;
let 
	internal_IC_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_internal_IC(x2_1_1, reset2_1_1);
	reset_Level_bool_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_Level_bool(x_1_1, reset_1_1, IC_1_1);
	reset_Level_int_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_Level_int(x1_1_1, reset1_1_1, IC1_1_1);
	reset_either_edge_bool_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_either_edge_bool(x9_1_1, reset7_1_1);
	reset_either_edge_int_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_either_edge_int(x10_1_1, reset8_1_1);
	reset_falling_edge_bool_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_falling_edge_bool(x7_1_1, reset3_1_1);
	reset_falling_edge_int_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_falling_edge_int(x8_1_1, reset4_1_1);
	reset_rising_edge_bool_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_rising_edge_bool(x5_1_1, reset5_1_1);
	reset_rising_edge_int_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_rising_edge_int(x6_1_1, reset6_1_1);
	reset_sampled_level_bool_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_sampled_level_bool(x11_1_1, reset11_1_1);
	reset_sampled_level_int_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_reset_sampled_level_int(x12_1_1, reset12_1_1);
	without_reset_ext_IC_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_without_reset_ext_IC(x3_1_1, IC3_1_1);
	without_reset_ext_IC1_1_1 = Disc_Integ_Forward_Euler_method_inherited_Sample_Time_PP_without_reset_ext_IC1(x4_1_1);
	y_1_1 = reset_Level_bool_1_1;
	y1_2_1 = reset_Level_int_1_1;
	y2_3_1 = internal_IC_1_1;
	y3_4_1 = without_reset_ext_IC_1_1;
	y4_5_1 = without_reset_ext_IC1_1_1;
	y5_6_1 = reset_rising_edge_bool_1_1;
	y6_7_1 = reset_rising_edge_int_1_1;
	y7_8_1 = reset_falling_edge_bool_1_1;
	y8_9_1 = reset_falling_edge_int_1_1;
	y9_10_1 = reset_either_edge_bool_1_1;
	y10_11_1 = reset_either_edge_int_1_1;
	y11_12_1 = reset_sampled_level_bool_1_1;
	y12_13_1 = reset_sampled_level_int_1_1;
	i_virtual_local= 0.0 -> 1.0;
tel

