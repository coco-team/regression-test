-- This file has been generated by CoCoSim


-- System nodes
node DTI_PP_DiscreteTimeIntegrator3 (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Add_1_1 : real;
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	DataTypeConversion2_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if ne0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion2_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Product1_1_1 = Sum3_1_1 * DataTypeConversion_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion1_1_1 * DataTypeConversion2_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + x0_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Add_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Add_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_level_1_1;
	eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
	ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
	ne1_1_1 = not((if UnitDelay2_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node DTI_PP_DiscreteTimeIntegrator2 (f_lpar_x_rpar__1_1 : real; x0_1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	Product_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	Product_1_1 = x0_1_1 * UnitDelay1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum3_1_1 = UnitDelay_1_1 + Product_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	F_lpar_x_rpar__1_1 = Sum3_1_1;
tel

node DTI_PP_DiscreteTimeIntegrator1 (f_lpar_x_rpar__1_1 : real; reset_falling_1_1 : bool)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Constant_1_1 : real;
	DataTypeConversion_1_1 : real;
	DataTypeConversion1_1_1 : real;
	Init_1_1 : real;
	Product_1_1 : real;
	Product2_1_1 : real;
	Sample_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	Sum5_1_1 : real;
	Sum6_1_1 : real;
	UnitDelay_1_1 : real;
	UnitDelay1_1_1 : real;
	UnitDelay2_1_1 : bool;
	eq0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Constant_1_1 = 0.00000000;
	DataTypeConversion_1_1 = (if eq0_1_1 then 1.0 else 0.0);
	DataTypeConversion1_1_1 = (if ne1_1_1 then 1.0 else 0.0);
	Init_1_1 = 0.00000000;
	Product_1_1 = Init_1_1 * UnitDelay1_1_1;
	Product2_1_1 = Sum3_1_1 * DataTypeConversion_1_1 * DataTypeConversion1_1_1;
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - UnitDelay_1_1 + Init_1_1;
	Sum4_1_1 = UnitDelay_1_1 + Product2_1_1;
	Sum5_1_1 = UnitDelay_1_1 + Product_1_1;
	Sum6_1_1 = Sum5_1_1 + Product2_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	UnitDelay1_1_1 = 1.00000000 -> pre Constant_1_1;
	UnitDelay2_1_1 = false -> pre reset_falling_1_1;
	eq0_1_1 = (if reset_falling_1_1 then 1.0 else 0.0) <= zero_1_1;
	ne1_1_1 = (if UnitDelay2_1_1 then 1.0 else 0.0) > zero_1_1;
	zero_1_1 = 0.00000000;
	F_lpar_x_rpar__1_1 = Sum6_1_1;
tel

node DTI_PP_DiscreteTimeIntegrator (f_lpar_x_rpar__1_1 : real)
returns (F_lpar_x_rpar__1_1 : real); 
var
	Sample_1_1 : real;
	Sum1_1_1 : real;
	UnitDelay_1_1 : real;
let 
	Sample_1_1 = 1.00000000 * f_lpar_x_rpar__1_1;
	Sum1_1_1 = Sample_1_1 + UnitDelay_1_1;
	UnitDelay_1_1 = 0.00000000 -> pre Sum1_1_1;
	F_lpar_x_rpar__1_1 = UnitDelay_1_1;
tel

node DTI_PP (In1_1_1 : bool; In2_1_1 : real)
returns (Out1_1_1 : real;
	Out2_2_1 : real;
	Out3_3_1 : real;
	Out4_4_1 : real); 
var
	Add_1_1 : real;
	DiscreteTimeIntegrator_1_1 : real;
	DiscreteTimeIntegrator1_1_1 : real;
	DiscreteTimeIntegrator2_1_1 : real;
	DiscreteTimeIntegrator3_1_1 : real;
	i_virtual_local : real;
let 
	Add_1_1 = (if In1_1_1 then 1.0 else 0.0) + In2_1_1;
	DiscreteTimeIntegrator_1_1 = DTI_PP_DiscreteTimeIntegrator(Add_1_1);
	DiscreteTimeIntegrator1_1_1 = DTI_PP_DiscreteTimeIntegrator1(Add_1_1, In1_1_1);
	DiscreteTimeIntegrator2_1_1 = DTI_PP_DiscreteTimeIntegrator2(Add_1_1, In2_1_1);
	DiscreteTimeIntegrator3_1_1 = DTI_PP_DiscreteTimeIntegrator3(Add_1_1, In1_1_1, In2_1_1);
	Out1_1_1 = DiscreteTimeIntegrator_1_1;
	Out2_2_1 = DiscreteTimeIntegrator1_1_1;
	Out3_3_1 = DiscreteTimeIntegrator2_1_1;
	Out4_4_1 = DiscreteTimeIntegrator3_1_1;
	i_virtual_local= 0.0 -> 1.0;
tel

